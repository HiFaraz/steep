#!/usr/bin/env python3
# Install any local script into your PATH using a temporary Homebrew formula, with one command and no taps.
# 1.0.0
"""
===============================================================================
Steep ‚Äî Local Script Installer via Temporary Homebrew Formula
===============================================================================

WHAT IT DOES
------------
Steep installs any *local* script into your PATH by generating a throwaway
Homebrew formula (no tap, no GitHub). You get a clean command like `myscript`
in `/opt/homebrew/bin` (or your Linuxbrew prefix).

COMMAND STRUCTURE
-----------------
Steep uses a clean subcommand structure:
‚Ä¢ `steep install ./script.sh`    - Install a script (primary command)
‚Ä¢ `steep list`                   - List all installed scripts
‚Ä¢ `steep uninstall NAME`         - Remove installed scripts
‚Ä¢ `steep extract NAME`           - Recreate script from installation
‚Ä¢ `steep doctor NAME`            - Diagnose script issues
‚Ä¢ `steep bundle DIR`             - Export all scripts
‚Ä¢ `steep restore DIR`            - Import scripts from bundle
‚Ä¢ `steep check ./script.sh`      - Validate before installing
‚Ä¢ `steep self-test`              - Run comprehensive tests

FEATURES
--------
‚Ä¢ Installs local files via a temporary **Homebrew formula** (no taps).
‚Ä¢ Puts the script on PATH under a clean **command name**.
‚Ä¢ Computes and embeds the **real SHA256** (no :no_check hacks).
‚Ä¢ Adds a cache-busting `?v=VERSION` so brew re-fetches on updates.
‚Ä¢ **Self-install/update** support: `steep install --self` (acts like upgrade, silent if not previously installed).
‚Ä¢ **Downgrade protection** (requires `--allow-downgrade` to install an older version).
‚Ä¢ **Metadata autodetect** from the target's 2nd & 3rd lines (desc/version).
‚Ä¢ **Print-only** mode for metadata: `steep install --print-metadata`.
‚Ä¢ **Dry-run** mode to preview the plan without installing: `steep install --dry-run`.
‚Ä¢ **Keep formula** option for debugging: `steep install --keep-formula`.
‚Ä¢ **List** all Steep-installed scripts: `steep list`.
‚Ä¢ **Uninstall** Steep-installed scripts: `steep uninstall NAME`.
‚Ä¢ **Doctor** diagnostics for troubleshooting: `steep doctor NAME`.
‚Ä¢ **Extract** an installed script back into the current directory:
  - `steep extract`              ‚Üí recreate **Steep** itself into CWD
  - `steep extract NAME`         ‚Üí recreate another command **only if installed by Steep**
  - `--force` to overwrite the destination file if it exists
  - `--as-original` to use the original filename from metadata
‚Ä¢ **Bundle and restore**: `steep bundle DIR` exports all scripts; `steep restore DIR` imports them
‚Ä¢ **Pre-flight validation**: `steep check SCRIPT` validates and shows what would be installed
‚Ä¢ **Self-testing**: `steep self-test` runs comprehensive functionality verification
‚Ä¢ **Conflict detection**: Warns about command name conflicts before installation
‚Ä¢ **JSON output**: `steep list --json` provides machine-readable output for automation
‚Ä¢ **Quiet mode** for CI environments: `--quiet`.
‚Ä¢ **Security guards** against world-writable paths and symlink surprises.
‚Ä¢ **Enhanced verification** with checksum validation post-install.
‚Ä¢ **Smart extract defaults** that prompt for original filenames in TTY.
‚Ä¢ **Verbose** output with `-v`.

SCRIPT HEADER FORMAT (the first 3 lines of *your* script)
---------------------------------------------------------
1) Shebang (whatever you want)
2) Description (commented with `#` or `//`)
3) Version     (commented with `#` or `//`)

Examples:

Bash:
    #!/usr/bin/env bash
    # Resize and optimize images in a folder
    # 2.3.1

Node:
    #!/usr/bin/env node
    // Convert CSV to JSON with sane defaults
    // 0.4.0

Python:
    #!/usr/bin/env python3
    # Tiny HTTP server with CORS
    # 1.0.0

QUICK USAGE
-----------
Self-install/update steep:
    steep install --self
    steep install --self --allow-downgrade   # if testing older version

Install any other script (metadata from lines 2‚Äì3):
    steep install ./path/to/script

Install with explicit metadata or custom name:
    steep install ./myscript.sh --desc "Helper" --version 2.0.0 --name helper

Just inspect metadata:
    steep install ./myscript.sh --print-metadata

Preview (no install):
    steep install ./myscript.sh --dry-run -v

Manage installed scripts:
    steep list                    # show all Steep-installed scripts
    steep uninstall mytool        # remove a Steep-installed script
    steep doctor mytool           # diagnose issues with a script

Extract previously installed script back into current directory:
    steep extract                 # recreates Steep itself
    steep extract myhelper        # recreates 'myhelper' if installed by Steep
    steep extract myhelper --force        # overwrite if file exists
    steep extract myhelper --as-original  # use original filename from metadata

Quiet mode for CI:
    steep install ./script.sh --quiet     # suppress non-error output

Security and verification:
    steep install ./script.sh --allow-world-writable  # override security check
    steep install ./script.sh --yes       # answer 'yes' to all prompts

Validation and portability:
    steep check ./script.sh       # validate script before installing
    steep bundle ./my-scripts     # export all scripts to directory
    steep restore ./my-scripts    # import scripts from directory
    steep self-test               # run comprehensive self-test

BEHAVIOR DETAILS
----------------
‚Ä¢ `steep install --self`:
    - Targets this file and **implicitly enables `--upgrade`**.
    - Will **only uninstall if already installed** (no noisy error when not).

‚Ä¢ Downgrade protection:
    - If installed version > new version, steep exits unless `--allow-downgrade`.

‚Ä¢ Name handling:
    - Default command name derived from filename (strips .sh/.py/.js/.ts/.rb etc.).
    - Use `--preserve-extension` to keep it, or `--name` to override.

‚Ä¢ Executable bit:
    - If target file isn't executable, steep sets it before install.

‚Ä¢ Management commands:
    - `steep list` scans Cellar for .steep-meta.json markers to find Steep-installed scripts.
    - `steep uninstall NAME` verifies Steep installation before removing.
    - `steep doctor NAME` diagnoses linking, permissions, and metadata issues.
    - `steep extract` recreates scripts using metadata; `--as-original` restores original filename.

‚Ä¢ Output modes:
    - `--quiet` suppresses non-error output (ideal for CI/automation).
    - `--verbose` shows detailed progress and debugging information.

‚Ä¢ Safety checks:
    - Verifies Homebrew prefix writability and suggests fixes.
    - Checks post-install linking and warns about potential issues.
    - Guards against world-writable source directories.
    - Warns when installing symlinks and shows real target.
    - Post-install checksum verification ensures integrity.

‚Ä¢ Smart defaults:
    - `--extract` prompts for original filename in TTY when applicable.
    - Enhanced cache busting with fragments for better reliability.
    - Human-friendly times and file sizes in `--list` output.

UNDER THE HOOD
--------------
1) Writes a Ruby formula to a temp dir. Filename matches the command name.
2) Formula uses:
       url "file:///ABS/PATH/TO/SCRIPT?v=VERSION", :using => :nounzip
       sha256 "<actual sha256>"
       bin.install "<basename>" => "<cmd_name>"
   and also writes a marker file in the Cellar to prove Steep installed it:
       (prefix/".steep-meta.json").write '{...metadata...}'
3) Runs:
       brew fetch  --force --formula /tmp/.../<cmd>.rb
       brew install --formula --build-from-source /tmp/.../<cmd>.rb

EXIT & OUTPUT
-------------
‚Ä¢ Prints Description + Version before installing.
‚Ä¢ On success: `‚úÖ Installed '<cmd>' at: <path>`.
‚Ä¢ Non-zero exit codes on: missing brew/file/metadata, blocked downgrade, not
  installed-by-steep on extract, brew failure.

===============================================================================
"""
import argparse
import hashlib
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import Optional, Tuple, List

__version__ = "1.0.0"

# -----------------------------
# Utilities
# -----------------------------

def which(cmd: str) -> bool:
    return shutil.which(cmd) is not None

def is_tty() -> bool:
    """Check if we're running in a TTY (interactive terminal)."""
    return sys.stdin.isatty() and sys.stdout.isatty()

def prompt_yes_no(question: str, default: bool = False) -> bool:
    """Prompt user for yes/no input. Only works in TTY."""
    if not is_tty():
        return default
    
    suffix = " [Y/n]" if default else " [y/N]"
    while True:
        try:
            response = input(question + suffix + ": ").strip().lower()
            if not response:
                return default
            if response in ('y', 'yes'):
                return True
            if response in ('n', 'no'):
                return False
            print("Please answer 'y' or 'n'")
        except (EOFError, KeyboardInterrupt):
            print()
            return default

def is_world_writable_path(path: Path) -> bool:
    """Check if path or any parent is world-writable."""
    current = path.resolve()
    while current != current.parent:
        try:
            stat = current.stat()
            # Check if world-writable (other write bit set)
            if stat.st_mode & 0o002:
                return True
        except (OSError, PermissionError):
            pass
        current = current.parent
    return False

def format_size(size_bytes: int) -> str:
    """Format file size in human-readable format."""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"

def format_time_ago(timestamp: int) -> str:
    """Format timestamp as human-readable relative time."""
    try:
        diff = int(time.time()) - timestamp
        if diff < 60:
            return "just now"
        elif diff < 3600:
            mins = diff // 60
            return f"{mins} minute{'s' if mins != 1 else ''} ago"
        elif diff < 86400:
            hours = diff // 3600
            return f"{hours} hour{'s' if hours != 1 else ''} ago"
        elif diff < 2592000:  # 30 days
            days = diff // 86400
            return f"{days} day{'s' if days != 1 else ''} ago"
        else:
            months = diff // 2592000
            return f"{months} month{'s' if months != 1 else ''} ago"
    except Exception:
        return "unknown"

def check_command_conflict(cmd_name: str) -> Tuple[bool, str]:
    """Check if command name conflicts with existing binaries."""
    try:
        # Check if command already exists
        existing_path = shutil.which(cmd_name)
        if existing_path:
            return True, existing_path
        return False, ""
    except Exception:
        return False, ""

def suggest_alternative_name(original: str) -> str:
    """Suggest alternative command name to avoid conflicts."""
    suggestions = [
        f"{original}-local",
        f"{original}-custom", 
        f"my-{original}",
        f"{original}2",
        f"{original}-steep"
    ]
    
    for suggestion in suggestions:
        conflict, _ = check_command_conflict(suggestion)
        if not conflict:
            return suggestion
    
    # Fallback: add random suffix
    import random
    return f"{original}-{random.randint(100, 999)}"

def collect_steep_scripts():
    """Collect all Steep-installed scripts with their metadata."""
    if not which("brew"):
        return []
    
    cellar = get_cellar()
    steep_installed = []
    
    if cellar.exists():
        for cmd_dir in cellar.iterdir():
            if not cmd_dir.is_dir():
                continue
            for version_dir in cmd_dir.iterdir():
                if not version_dir.is_dir():
                    continue
                meta_path = version_dir / ".steep-meta.json"
                if meta_path.exists():
                    try:
                        meta = json.loads(meta_path.read_text(encoding="utf-8"))
                        
                        # Find the binary
                        bin_path = version_dir / "bin" / cmd_dir.name
                        if not bin_path.exists():
                            bin_path = version_dir / "bin" / meta.get("cmd", cmd_dir.name)
                        
                        if bin_path.exists():
                            steep_installed.append({
                                "name": cmd_dir.name,
                                "meta": meta,
                                "bin_path": bin_path,
                                "version_dir": version_dir
                            })
                        break
                    except Exception:
                        pass
    
    return steep_installed

def to_cmd_name(p: Path, preserve_ext: bool) -> str:
    """Derive a brew-friendly command name from path."""
    name = p.name
    if not preserve_ext:
        for ext in (".sh", ".py", ".bash", ".zsh", ".js", ".ts", ".rb", ".mjs", ".tsx", ".jsx", ".pl", ".go", ".rs", ".swift", ".kt", ".java", ".lua", ".php"):
            if name.endswith(ext):
                name = name[: -len(ext)]
                break
    return re.sub(r"[^a-z0-9+_.-]", "-", name.lower())

def to_class_name(cmd: str) -> str:
    """
    UpperCamelCase Ruby class name for the formula. Must start with a letter.
    Enforces [A-Za-z][A-Za-z0-9]* segments, collapses repeats, truncates long names.
    """
    # Split on non-alphanumeric, filter empty/non-alpha-starting parts
    parts = []
    for part in re.split(r"[^A-Za-z0-9]+", cmd):
        if part and part[0].isalpha():
            # Keep only valid segments that start with letter
            clean_part = re.sub(r"[^A-Za-z0-9]", "", part)
            if clean_part and clean_part[0].isalpha():
                parts.append(clean_part)
    
    if not parts:
        return "Tool"
    
    # Capitalize each part and join
    camel = "".join(p.capitalize() for p in parts)
    
    # Collapse repeated sequences (e.g., "TestTestTest" -> "Test")
    prev_camel = ""
    while camel != prev_camel:
        prev_camel = camel
        # Find repeated patterns and collapse them
        for i in range(1, len(camel) // 2 + 1):
            pattern = camel[:i]
            if len(pattern) >= 2:
                # Count how many times pattern repeats at the start
                count = 0
                pos = 0
                while pos + len(pattern) <= len(camel) and camel[pos:pos+len(pattern)] == pattern:
                    count += 1
                    pos += len(pattern)
                
                if count >= 2:
                    # Replace repeated pattern with single occurrence
                    camel = pattern + camel[pos:]
                    break
    
    # Truncate if too long (Ruby class names should be reasonable)
    # Use hash suffix for uniqueness if we need to truncate
    if len(camel) > 200:
        # Create a hash of the original for uniqueness
        hash_suffix = hashlib.sha256(camel.encode()).hexdigest()[:8].capitalize()
        camel = camel[:190] + hash_suffix
    elif len(camel) > 50:
        camel = camel[:50]
    
    # Ensure it still starts with a letter after all processing
    if not camel or not camel[0].isalpha():
        camel = "Tool" + camel
    
    return camel

def rb_escape(s: str) -> str:
    """Escape for Ruby double-quoted strings."""
    return s.replace("\\", "\\\\").replace('"', '\\"')

def run(cmd, **kwargs):
    """Run a subprocess, exiting with its code on failure."""
    try:
        subprocess.run(cmd, check=True, **kwargs)
    except subprocess.CalledProcessError as e:
        sys.exit(e.returncode)

def extract_metadata(script_path: Path):
    """
    Read description (line 2) and version (line 3).
    Strips leading '#', '//' and whitespace.
    """
    try:
        with script_path.open("r", encoding="utf-8") as f:
            lines = f.readlines()
        desc = None
        ver = None
        if len(lines) >= 2:
            desc = re.sub(r"^\s*(#|//)\s*", "", lines[1].strip())
        if len(lines) >= 3:
            ver = re.sub(r"^\s*(#|//)\s*", "", lines[2].strip())
        return (desc or None), (ver or None)
    except Exception:
        return None, None

def sha256_file(path: Path) -> str:
    h = hashlib.sha256()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(1024 * 1024), b""):
            h.update(chunk)
    return h.hexdigest()

def get_formula_info(cmd_name: str):
    """Return (stable_version, installed_versions:List[str]) or (None, [])."""
    try:
        out = subprocess.check_output(["brew", "info", "--json=v2", cmd_name], text=True)
        data = json.loads(out)
        if not data.get("formulae"):
            return None, []
        f = data["formulae"][0]
        stable = f["versions"]["stable"]
        installed = []
        for inst in f.get("installed", []):
            installed.append(inst.get("version"))
        return stable, installed
    except subprocess.CalledProcessError:
        return None, []
    except Exception:
        return None, []

def get_cellar() -> Path:
    out = subprocess.check_output(["brew", "--cellar"], text=True).strip()
    return Path(out)

def get_prefix() -> Path:
    """Get Homebrew prefix path."""
    out = subprocess.check_output(["brew", "--prefix"], text=True).strip()
    return Path(out)

def check_brew_writable() -> Tuple[bool, str]:
    """Check if brew prefix is writable and return guidance if not."""
    try:
        prefix = get_prefix()
        if prefix.exists() and not os.access(prefix, os.W_OK):
            # Check if it's owned by current user
            stat = prefix.stat()
            current_uid = os.getuid()
            if stat.st_uid != current_uid:
                return False, f"sudo chown -R $(whoami) {prefix}"
            else:
                return False, f"chmod u+w {prefix}"
        return True, ""
    except Exception:
        return True, ""  # Assume writable if we can't check

def verify_install_linked(cmd_name: str) -> Tuple[bool, str]:
    """
    Verify that the installed command is properly linked.
    Returns (is_linked, fix_command).
    """
    try:
        prefix = get_prefix()
        expected_link = prefix / "bin" / cmd_name
        
        if not expected_link.exists():
            return False, f"brew link --overwrite {cmd_name}"
        
        # Check if it points into Cellar
        if expected_link.is_symlink():
            target = expected_link.resolve()
            cellar = get_cellar()
            if not str(target).startswith(str(cellar)):
                return False, f"brew link --overwrite {cmd_name}"
        
        return True, ""
    except Exception:
        return True, ""  # Assume linked if we can't check

def get_keg_path(cmd_name: str, version: Optional[str]) -> Optional[Path]:
    cellar = get_cellar()
    if version:
        p = cellar / cmd_name / version
        if p.exists():
            return p
    # Fallback: pick latest existing version dir
    base = cellar / cmd_name
    if base.exists():
        versions = sorted([d for d in base.iterdir() if d.is_dir()])
        return versions[-1] if versions else None
    return None

def parse_version(v: str):
    """Loose semver-ish comparison key: (major, minor, patch, tail)."""
    if v is None:
        return (0, 0, 0, "")
    m = re.match(r"^\s*(\d+)(?:\.(\d+))?(?:\.(\d+))?(.*)$", v.strip())
    if not m:
        return (0, 0, 0, v.strip())
    major = int(m.group(1) or 0)
    minor = int(m.group(2) or 0)
    patch = int(m.group(3) or 0)
    tail = (m.group(4) or "").strip()
    return (major, minor, patch, tail)

def is_installed(name: str) -> bool:
    """Return True if brew has this formula installed (any version)."""
    r = subprocess.run(
        ["brew", "list", "--versions", name],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )
    return r.returncode == 0 and bool(r.stdout.strip())

# -----------------------------
# Main
# -----------------------------

class CleanHelpFormatter(argparse.RawDescriptionHelpFormatter):
    """Custom formatter to clean up subcommand help display."""
    
    def _format_usage(self, usage, actions, groups, prefix):
        # Customize usage line to be cleaner
        if prefix is None:
            prefix = 'usage: '
        return f"{prefix}steep [-h] [--quiet] [--verbose] <subcommand> [args]\n\n"

def create_parser():
    """Create the main argument parser with subcommands."""
    parser = argparse.ArgumentParser(
        prog="steep",
        description="Install any local script into your PATH using Homebrew formulas.",
        formatter_class=CleanHelpFormatter,
        epilog="Run 'steep SUBCOMMAND --help' for more information on each subcommand."
    )
    
    # Global options that apply to all subcommands
    parser.add_argument("--quiet", "-q", action="store_true", help="Suppress non-error output (CI mode)")
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    
    # Create subparsers
    subparsers = parser.add_subparsers(
        dest="subcommand", 
        title="available subcommands",
        metavar="subcommand"
    )
    
    # Install subcommand
    install_parser = subparsers.add_parser("install", help="Install a script as a command")
    install_parser.add_argument("script", nargs="?", help="Path to the script file to install")
    install_parser.add_argument("--self", action="store_true", help="Install or upgrade this steep script")
    install_parser.add_argument("--desc", help="Short description for brew (default: read from line 2)")
    install_parser.add_argument("--version", help="Version string (default: read from line 3)")
    install_parser.add_argument("--name", help="Installed command name (default: derived from filename)")
    install_parser.add_argument("--preserve-extension", action="store_true", help="Keep the original file extension")
    install_parser.add_argument("--keep-formula", action="store_true", help="Keep the generated formula (prints path)")
    install_parser.add_argument("--upgrade", action="store_true", help="Uninstall first before reinstalling")
    install_parser.add_argument("--allow-downgrade", action="store_true", help="Allow installing a lower version than current")
    install_parser.add_argument("--print-metadata", action="store_true", help="Print detected desc/version and exit")
    install_parser.add_argument("--dry-run", action="store_true", help="Show what would be installed, do nothing")
    install_parser.add_argument("--yes", "-y", action="store_true", help="Answer 'yes' to all prompts (non-interactive mode)")
    install_parser.add_argument("--allow-world-writable", action="store_true", help="Allow installation from world-writable directories")
    install_parser.add_argument("--force", action="store_true", help="Force installation (overwrite existing)")
    
    # List subcommand
    list_parser = subparsers.add_parser("list", help="List all scripts installed by Steep")
    list_parser.add_argument("--json", action="store_true", help="Output machine-readable JSON")
    
    # Uninstall subcommand
    uninstall_parser = subparsers.add_parser("uninstall", help="Uninstall a script that was installed by Steep")
    uninstall_parser.add_argument("name", help="Name of the script to uninstall")
    
    # Extract subcommand
    extract_parser = subparsers.add_parser("extract", help="Recreate installed script into the current directory")
    extract_parser.add_argument("name", nargs="?", default="steep", help="Name of script to extract (default: steep)")
    extract_parser.add_argument("--force", action="store_true", help="Overwrite existing file when extracting")
    extract_parser.add_argument("--as-original", action="store_true", help="Extract using original filename from metadata")
    
    # Doctor subcommand
    doctor_parser = subparsers.add_parser("doctor", help="Diagnose issues with an installed script")
    doctor_parser.add_argument("name", help="Name of the script to diagnose")
    
    # Bundle subcommand
    bundle_parser = subparsers.add_parser("bundle", help="Bundle all Steep-installed scripts to a directory")
    bundle_parser.add_argument("directory", help="Directory to create bundle in")
    
    # Restore subcommand
    restore_parser = subparsers.add_parser("restore", help="Restore scripts from a bundle directory")
    restore_parser.add_argument("directory", help="Directory containing bundle to restore")
    
    # Check subcommand
    check_parser = subparsers.add_parser("check", help="Validate script and show what would be installed")
    check_parser.add_argument("script", help="Path to the script file to check")
    
    # Self-test subcommand
    self_test_parser = subparsers.add_parser("self-test", help="Run comprehensive self-test")
    
    return parser


def main():
    parser = create_parser()
    args = parser.parse_args()
    
    # Route to appropriate subcommand handler
    if args.subcommand == "install":
        do_install(args)
    elif args.subcommand == "list":
        do_list(getattr(args, 'json', False))
    elif args.subcommand == "uninstall":
        do_uninstall(args.name)
    elif args.subcommand == "extract":
        do_extract(args.name, getattr(args, 'force', False), getattr(args, 'as_original', False))
    elif args.subcommand == "doctor":
        do_doctor(args.name)
    elif args.subcommand == "bundle":
        do_bundle(args.directory)
    elif args.subcommand == "restore":
        do_restore(args.directory)
    elif args.subcommand == "check":
        do_check(args.script)
    elif args.subcommand == "self-test":
        do_self_test()
    else:
        # No subcommand provided, show help
        parser.print_help()
        sys.exit(1)

def do_install(args):
    """Handle the install subcommand (refactored from original main logic)."""
    
    # --self implies --upgrade and targets this file
    if getattr(args, 'self', False):
        args.script = str(Path(__file__).resolve())
        args.upgrade = True
        
        # Special handling for --self --dry-run: validate environment
        if getattr(args, 'dry_run', False):
            # Check if brew is available
            if not which("brew"):
                print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
                sys.exit(127)
            
            # Validate metadata from this file
            self_path = Path(__file__).resolve()
            test_desc, test_ver = extract_metadata(self_path)
            if not test_desc or not test_ver:
                print("Error: steep install --self requires valid metadata in this file.", file=sys.stderr)
                sys.exit(2)

    if not getattr(args, 'script', None):
        print("Error: You must provide a script path or use --self", file=sys.stderr)
        sys.exit(1)

    script_path = Path(args.script).expanduser()
    
    # Handle symlinks with warning
    if script_path.is_symlink():
        real_path = script_path.resolve()
        if not getattr(args, 'quiet', False):
            print(f"‚ö†Ô∏è  Source is a symlink: {script_path}")
            print(f"   Real path: {real_path}")
        
        if not getattr(args, 'yes', False) and not prompt_yes_no("Proceed with real target", default=True):
            print("Installation cancelled.")
            sys.exit(1)
        
        script_path = real_path
    else:
        script_path = script_path.resolve()
    
    if not script_path.exists():
        print(f"Error: Script not found: {script_path}", file=sys.stderr)
        sys.exit(2)
    
    # Security check: world-writable directories
    if is_world_writable_path(script_path) and not getattr(args, 'allow_world_writable', False):
        print(f"üõ°Ô∏è  Security: Script is in a world-writable directory: {script_path.parent}", file=sys.stderr)
        print("   This could be a security risk if the script is not owned by you.", file=sys.stderr)
        
        # Check ownership
        try:
            current_uid = os.getuid()
            file_uid = script_path.stat().st_uid
            if file_uid != current_uid:
                print(f"   Script is owned by UID {file_uid}, you are UID {current_uid}", file=sys.stderr)
                print("   Use --allow-world-writable to override this check.", file=sys.stderr)
                sys.exit(3)
        except (OSError, AttributeError):
            pass  # Skip ownership check on systems where it's not available
        
        if not getattr(args, 'yes', False) and not prompt_yes_no("Continue anyway", default=False):
            print("Installation cancelled for security.")
            sys.exit(3)

    # Read metadata (or use overrides)
    auto_desc, auto_version = extract_metadata(script_path)
    desc = getattr(args, 'desc', None) or auto_desc
    ver = getattr(args, 'version', None) or auto_version

    if not desc:
        print("Error: Description not provided and could not be read from line 2.", file=sys.stderr)
        print("\nExpected format for your script's first 3 lines:", file=sys.stderr)
        print("  #!/usr/bin/env python3  (or bash, node, etc.)", file=sys.stderr)
        print("  # Short description of what the script does", file=sys.stderr)
        print("  # 1.0.0  (version number)", file=sys.stderr)
        print("\nOr provide explicitly with: --desc \"Your description\"", file=sys.stderr)
        sys.exit(2)
    if not ver:
        print("Error: Version not provided and could not be read from line 3.", file=sys.stderr)
        print("\nExpected format for your script's first 3 lines:", file=sys.stderr)
        print("  #!/usr/bin/env python3  (or bash, node, etc.)", file=sys.stderr)
        print("  # Short description of what the script does", file=sys.stderr) 
        print("  # 1.0.0  (version number)", file=sys.stderr)
        print("\nOr provide explicitly with: --version \"1.0.0\"", file=sys.stderr)
        sys.exit(2)

    cmd_name = getattr(args, 'name', None) or to_cmd_name(script_path, getattr(args, 'preserve_extension', False))

    # Metadata only
    if getattr(args, 'print_metadata', False):
        print(f"Description: {desc}")
        print(f"Version:     {ver}")
        print(f"Command:     {cmd_name}")
        sys.exit(0)

    if not which("brew"):
        print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)

    # Downgrade protection
    installed_ver, _ = get_formula_info(cmd_name)
    if installed_ver:
        try:
            if parse_version(ver) < parse_version(installed_ver) and not getattr(args, 'allow_downgrade', False):
                print(f"‚ö†Ô∏è  Downgrade detected: installed {installed_ver} > new {ver}")
                print("   Use --allow-downgrade to override.")
                sys.exit(3)
        except Exception:
            pass  # if parsing fails, skip check

    # Ensure executable bit
    mode = script_path.stat().st_mode
    if (mode & 0o111) == 0:
        if getattr(args, 'verbose', False):
            print(f"Making executable: {script_path}")
        script_path.chmod(mode | 0o111)

    class_name = to_class_name(cmd_name)
    checksum = sha256_file(script_path)
    # Enhanced cache busting: query parameter + fragment
    file_url_with_q = f"{script_path.as_uri()}?v={ver}#sha={checksum[:16]}"
    basename = script_path.name

    # Check brew writability before proceeding
    writable, fix_cmd = check_brew_writable()
    if not writable and not getattr(args, 'quiet', False):
        print(f"‚ö†Ô∏è  Homebrew prefix not writable. If install fails, try: {fix_cmd}")

    # Metadata marker JSON to record "installed by Steep" (richer metadata)
    # (Stored at <Cellar>/<cmd>/<version>/.steep-meta.json)
    meta = {
        "installed_by": "steep",
        "steep_version": "1.0.0",
        "cmd": cmd_name,
        "desc": desc,
        "version": ver,
        "source_url": file_url_with_q,
        "checksum": checksum,
        "basename": basename,
        "original_abs_path": str(script_path.resolve()),
        "preserve_extension": getattr(args, 'preserve_extension', False),
        "renamed_to": cmd_name if cmd_name != script_path.stem else None,
        "installed_at": int(time.time()),
        "platform": sys.platform,
        "python_version": sys.version.split()[0],
    }
    meta_json = json.dumps(meta, separators=(",", ":"), ensure_ascii=False)

    # Generate formula text (writes marker file in prefix)
    formula = f"""class {class_name} < Formula
  desc "{rb_escape(desc)}"
  version "{rb_escape(ver)}"
  url "{rb_escape(file_url_with_q)}", :using => :nounzip
  sha256 "{checksum}"

  def install
    bin.install "{rb_escape(basename)}" => "{rb_escape(cmd_name)}"
    # Mark this keg as installed by Steep and save basic metadata.
    (prefix/".steep-meta.json").write <<~EOS
{meta_json}
EOS
  end
end
"""

    tmpdir = tempfile.TemporaryDirectory(prefix="steep-")
    rb_path = Path(tmpdir.name) / f"{cmd_name}.rb"
    rb_path.write_text(formula, encoding="utf-8")
    
    # Verbose output shows formula path
    if getattr(args, 'verbose', False):
        print(f"Generated formula: {rb_path}")

    # Preview / Dry-run (respect quiet mode)
    if not getattr(args, 'quiet', False):
        print(f"üì¶ Plan to install '{cmd_name}'")
        print(f"   Description: {desc}")
        print(f"   Version:     {ver}")
        print(f"   Source URL:  {file_url_with_q}")
        print(f"   SHA256:      {checksum}")
    if getattr(args, 'dry_run', False):
        if not getattr(args, 'quiet', False):
            print("üìù Dry-run only. Generated formula at:")
            print(f"   {rb_path}")
            if not getattr(args, 'keep_formula', False):
                print("   (Use --keep-formula to retain the file)")
        tmpdir.cleanup()
        sys.exit(0)

    # Uninstall first if upgrading, but only if it exists (avoids noisy error)
    if getattr(args, 'upgrade', False) and is_installed(cmd_name):
        if getattr(args, 'verbose', False):
            print(f"Uninstalling existing '{cmd_name}' ‚Ä¶")
        run(["brew", "uninstall", "--force", cmd_name])

    if getattr(args, 'verbose', False):
        print(f"Formula written to: {rb_path}")
        print("Forcing re-fetch to avoid stale cache‚Ä¶")

    # Force fresh fetch and *explicitly* treat as a formula (no cask ambiguity)
    subprocess.run(["brew", "fetch", "--force", "--formula", str(rb_path)], check=False)

    if getattr(args, 'verbose', False):
        print("Installing via Homebrew‚Ä¶")

    run(["brew", "install", "--formula", "--build-from-source", str(rb_path)])

    # Post-install verification and report
    install_path = None
    try:
        out = subprocess.check_output(["which", cmd_name], text=True).strip()
        install_path = Path(out)
        print(f"‚úÖ Installed '{cmd_name}' at: {out}")
        
        # Verify linking (quiet mode shows warnings too)
        linked, fix_cmd = verify_install_linked(cmd_name)
        if not linked:
            print(f"‚ö†Ô∏è  Command may not be properly linked. Try: {fix_cmd}")
            
    except subprocess.CalledProcessError:
        # Still try to verify linking even if 'which' fails
        linked, fix_cmd = verify_install_linked(cmd_name)
        if linked:
            prefix = get_prefix()
            install_path = prefix / "bin" / cmd_name
            print(f"‚úÖ Installed '{cmd_name}' at: {install_path}")
        else:
            print(f"‚úÖ Installed '{cmd_name}' but may need linking: {fix_cmd}")
    
    # Checksum preflight: verify installed file matches source
    if install_path and install_path.exists():
        try:
            # Follow symlink to actual installed file
            actual_file = install_path.resolve() if install_path.is_symlink() else install_path
            if actual_file.exists():
                installed_checksum = sha256_file(actual_file)
                if installed_checksum != checksum:
                    print(f"‚ö†Ô∏è  Checksum mismatch! Source: {checksum[:16]}... vs Installed: {installed_checksum[:16]}...")
                elif getattr(args, 'verbose', False):
                    print(f"‚úÖ Checksum verified: {checksum[:16]}...")
        except Exception as e:
            if getattr(args, 'verbose', False):
                print(f"‚ö†Ô∏è  Could not verify checksum: {e}")

    if getattr(args, 'keep_formula', False) and not getattr(args, 'quiet', False):
        print(f"Kept formula at: {rb_path}")
        tmpdir.cleanup = lambda: None  # keep it
    else:
        tmpdir.cleanup()

# -----------------------------
# Extract logic
# -----------------------------

def do_uninstall(name: str):
    """Uninstall a script that was installed by Steep."""
    if not which("brew"):
        print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)
    
    stable_ver, versions = get_formula_info(name)
    if not stable_ver and not versions:
        print(f"Error: '{name}' is not installed via Homebrew.", file=sys.stderr)
        sys.exit(4)
    
    keg = get_keg_path(name, stable_ver)
    if not keg:
        print(f"Error: Could not locate Cellar keg for '{name}'.", file=sys.stderr)
        sys.exit(5)
    
    meta_path = keg / ".steep-meta.json"
    if not meta_path.exists():
        print(f"Error: '{name}' does not appear to be installed by Steep (no marker found).", file=sys.stderr)
        print("This formula was installed by other means and should be uninstalled with 'brew uninstall'.", file=sys.stderr)
        sys.exit(6)
    
    # Read metadata to show what we're removing
    try:
        meta = json.loads(meta_path.read_text(encoding="utf-8"))
        print(f"üóëÔ∏è  Uninstalling '{name}'")
        print(f"   Description: {meta.get('desc', 'N/A')}")
        print(f"   Version:     {meta.get('version', 'N/A')}")
    except Exception:
        print(f"üóëÔ∏è  Uninstalling '{name}'")
    
    run(["brew", "uninstall", "--force", name])
    print(f"‚úÖ Uninstalled '{name}'")

def do_list(json_output: bool = False):
    """List all scripts installed by Steep."""
    if not which("brew"):
        print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)
    
    cellar = get_cellar()
    steep_installed = []
    
    # Scan all kegs for .steep-meta.json markers
    if cellar.exists():
        for cmd_dir in cellar.iterdir():
            if not cmd_dir.is_dir():
                continue
            # Check each version directory
            for version_dir in cmd_dir.iterdir():
                if not version_dir.is_dir():
                    continue
                meta_path = version_dir / ".steep-meta.json"
                if meta_path.exists():
                    try:
                        meta = json.loads(meta_path.read_text(encoding="utf-8"))
                        
                        # Get file size and install time
                        bin_path = version_dir / "bin" / cmd_dir.name
                        if not bin_path.exists():
                            # Try with metadata cmd name
                            bin_path = version_dir / "bin" / meta.get("cmd", cmd_dir.name)
                        
                        file_size = 0
                        if bin_path.exists():
                            try:
                                file_size = bin_path.stat().st_size
                            except (OSError, PermissionError):
                                pass
                        
                        steep_installed.append({
                            "name": cmd_dir.name,
                            "version": meta.get("version", "unknown"),
                            "desc": meta.get("desc", ""),
                            "path": version_dir,
                            "installed_at": meta.get("installed_at"),
                            "file_size": file_size,
                            "meta": meta
                        })
                        break  # Only need one version per command
                    except Exception:
                        pass
    
    if not steep_installed:
        if json_output:
            print(json.dumps([], indent=2))
        else:
            print("No scripts installed by Steep found.")
        return
    
    # Sort by name
    steep_installed.sort(key=lambda x: x["name"])
    
    if json_output:
        # Output machine-readable JSON
        json_data = []
        for item in steep_installed:
            json_data.append({
                "name": item["name"],
                "version": item["version"],
                "description": item["desc"],
                "file_size": item["file_size"],
                "installed_at": item["installed_at"],
                "metadata": item["meta"]
            })
        print(json.dumps(json_data, indent=2))
    else:
        # Human-friendly output
        print(f"üì¶ Scripts installed by Steep ({len(steep_installed)} total):\n")
        for item in steep_installed:
            # Format with human-friendly info
            size_info = format_size(item['file_size']) if item['file_size'] > 0 else ""
            time_info = format_time_ago(item['installed_at']) if item['installed_at'] else ""
            
            extras = []
            if size_info:
                extras.append(size_info)
            if time_info:
                extras.append(time_info)
            
            extra_info = f" ‚Ä¢ {' ‚Ä¢ '.join(extras)}" if extras else ""
            
            print(f"  {item['name']} ({item['version']}){extra_info}")
            if item['desc']:
                print(f"    {item['desc']}")
        print("\nUse 'steep uninstall NAME' to remove a script.")
        print("Use 'steep extract NAME' to recreate a script's source.")

def do_extract(name: str, force: bool, as_original: bool):
    if not which("brew"):
        print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)

    stable_ver, versions = get_formula_info(name)
    if not stable_ver and not versions:
        print(f"Error: '{name}' is not installed via Homebrew.", file=sys.stderr)
        sys.exit(4)

    keg = get_keg_path(name, stable_ver)
    if not keg:
        print(f"Error: Could not locate Cellar keg for '{name}'.", file=sys.stderr)
        sys.exit(5)

    meta_path = keg / ".steep-meta.json"
    if not meta_path.exists():
        print(f"Error: '{name}' does not appear to be installed by Steep (no marker found).", file=sys.stderr)
        sys.exit(6)

    # Read metadata (optional)
    try:
        meta = json.loads(meta_path.read_text(encoding="utf-8"))
    except Exception:
        meta = None

    bin_src = keg / "bin" / name
    if not bin_src.exists():
        # If renamed, fall back to cmd name or basename from metadata
        if meta and meta.get("cmd"):
            candidate = keg / "bin" / meta["cmd"]
            if candidate.exists():
                bin_src = candidate
        if not bin_src.exists() and meta and meta.get("basename"):
            candidate = keg / "bin" / meta["basename"]
            if candidate.exists():
                bin_src = candidate

    if not bin_src.exists():
        print(f"Error: Could not find binary for '{name}' in {keg/'bin'}.", file=sys.stderr)
        sys.exit(7)

    # Determine destination filename with smart --as-original default
    use_original = as_original
    
    # Smart default: if metadata has basename with extension and --as-original not explicitly set
    if not as_original and meta and meta.get("basename"):
        original_basename = meta["basename"]
        # Check if original had an extension that was stripped
        if "." in original_basename and not original_basename.endswith(tuple([".txt", ".log", ".dat"])):
            # In TTY, prompt once; non-TTY defaults to current behavior
            if is_tty():
                use_original = prompt_yes_no(f"Extract as original filename '{original_basename}'", default=True)
            # Non-TTY keeps current behavior (use command name)
    
    if use_original and meta and meta.get("basename"):
        dest_name = meta["basename"]
    else:
        dest_name = name
    
    dest = Path.cwd() / dest_name
    if dest.exists() and not force:
        print(f"Error: '{dest}' already exists. Use --force to overwrite.", file=sys.stderr)
        sys.exit(8)

    # Copy and preserve mode
    data = bin_src.read_bytes()
    dest.write_bytes(data)
    mode = bin_src.stat().st_mode
    dest.chmod(mode | 0o111)

    print(f"üß© Extracted '{name}' to: {dest}")

def do_doctor(name: str):
    """Diagnose issues with an installed script."""
    if not which("brew"):
        print("‚ùå Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)
    
    print(f"ü©∫ Diagnosing '{name}'...\n")
    
    # Check if installed via Homebrew
    stable_ver, versions = get_formula_info(name)
    if not stable_ver and not versions:
        print(f"‚ùå '{name}' is not installed via Homebrew.")
        print(f"   Install with: brew install {name}")
        sys.exit(4)
    
    print(f"‚úÖ Installed via Homebrew (version: {stable_ver})")
    
    # Check for Steep marker
    keg = get_keg_path(name, stable_ver)
    if not keg:
        print(f"‚ùå Could not locate Cellar keg for '{name}'")
        sys.exit(5)
    
    meta_path = keg / ".steep-meta.json"
    if not meta_path.exists():
        print(f"‚ö†Ô∏è  '{name}' was not installed by Steep")
        print(f"   This is a regular Homebrew formula")
        return
    
    print(f"‚úÖ Installed by Steep")
    
    # Read and display metadata
    try:
        meta = json.loads(meta_path.read_text(encoding="utf-8"))
        print(f"   Description: {meta.get('desc', 'N/A')}")
        print(f"   Version: {meta.get('version', 'N/A')}")
        if meta.get("installed_at"):
            import datetime
            install_date = datetime.datetime.fromtimestamp(meta["installed_at"])
            print(f"   Installed: {install_date.strftime('%Y-%m-%d %H:%M:%S')}")
        if meta.get("original_abs_path"):
            print(f"   Source: {meta['original_abs_path']}")
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not read metadata: {e}")
    
    # Check linking
    linked, fix_cmd = verify_install_linked(name)
    if linked:
        print("‚úÖ Properly linked")
        try:
            out = subprocess.check_output(["which", name], text=True).strip()
            print(f"   Available at: {out}")
        except subprocess.CalledProcessError:
            print("   (but 'which' command failed)")
    else:
        print(f"‚ùå Not properly linked")
        print(f"   Fix with: {fix_cmd}")
    
    # Check prefix writability and show Homebrew info
    try:
        prefix = get_prefix()
        cellar = get_cellar()
        print(f"‚ÑπÔ∏è  Homebrew prefix: {prefix}")
        print(f"   Cellar: {cellar}")
        
        # Check if this might be Rosetta (x86_64 on Apple Silicon)
        if sys.platform == "darwin":
            try:
                arch_out = subprocess.check_output(["arch"], text=True).strip()
                brew_arch = subprocess.check_output(["arch", "-x86_64", "which", "brew"], stderr=subprocess.DEVNULL, text=True).strip()
                if arch_out != "i386" and brew_arch:
                    print(f"   Architecture: {arch_out} (Homebrew may be running under Rosetta)")
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
    except Exception:
        pass
    
    writable, fix_cmd = check_brew_writable()
    if writable:
        print("‚úÖ Homebrew prefix is writable")
    else:
        print("‚ö†Ô∏è  Homebrew prefix not writable")
        print(f"   Fix with: {fix_cmd}")
    
    # Check if source file still exists
    if meta and meta.get("original_abs_path"):
        source_path = Path(meta["original_abs_path"])
        if source_path.exists():
            print("‚úÖ Source file still exists")
            # Check if it has changed
            current_checksum = sha256_file(source_path)
            if current_checksum == meta.get("checksum"):
                print("   Source unchanged since install")
            else:
                print("‚ö†Ô∏è  Source file has changed since install")
                print(f"   Consider: steep install {source_path} --upgrade")
        else:
            print("‚ùå Source file no longer exists")
            print(f"   Original path: {source_path}")

def do_bundle(bundle_dir: str):
    """Bundle all Steep-installed scripts to a portable directory."""
    if not which("brew"):
        print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)
    
    bundle_path = Path(bundle_dir).resolve()
    
    # Create bundle directory
    try:
        bundle_path.mkdir(parents=True, exist_ok=True)
    except OSError as e:
        print(f"Error: Cannot create bundle directory '{bundle_path}': {e}", file=sys.stderr)
        sys.exit(1)
    
    # Collect all Steep scripts
    steep_scripts = collect_steep_scripts()
    if not steep_scripts:
        print("No Steep-installed scripts found.")
        return
    
    bundle_info = {
        "bundle_version": "1.0",
        "created_at": int(time.time()),
        "created_by": f"steep {__version__}",
        "scripts": []
    }
    
    print(f"üì¶ Creating bundle in: {bundle_path}")
    
    for script in steep_scripts:
        name = script["name"]
        version = script["version"]
        
        # Find the keg and binary
        keg = get_keg_path(name, version)
        if not keg:
            print(f"‚ö†Ô∏è  Skipping '{name}': could not locate keg")
            continue
            
        meta_path = keg / ".steep-meta.json"
        if not meta_path.exists():
            print(f"‚ö†Ô∏è  Skipping '{name}': no metadata found")
            continue
        
        # Read metadata
        try:
            meta = json.loads(meta_path.read_text(encoding="utf-8"))
        except Exception as e:
            print(f"‚ö†Ô∏è  Skipping '{name}': could not read metadata: {e}")
            continue
        
        # Find binary file
        bin_src = keg / "bin" / name
        if not bin_src.exists():
            # Try with cmd name from metadata
            if meta.get("cmd"):
                bin_src = keg / "bin" / meta["cmd"]
        if not bin_src.exists():
            print(f"‚ö†Ô∏è  Skipping '{name}': binary not found in keg")
            continue
        
        # Copy script to bundle with original filename
        original_name = meta.get("basename", name)
        dest_path = bundle_path / original_name
        
        try:
            # Copy file content and preserve permissions
            data = bin_src.read_bytes()
            dest_path.write_bytes(data)
            mode = bin_src.stat().st_mode
            dest_path.chmod(mode | 0o111)
            
            # Add to bundle manifest
            bundle_info["scripts"].append({
                "filename": original_name,
                "command_name": name,
                "metadata": meta
            })
            
            print(f"  ‚úÖ {original_name} ‚Üí {name}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Failed to copy '{name}': {e}")
            continue
    
    # Write bundle manifest
    manifest_path = bundle_path / ".steep-bundle.json"
    try:
        manifest_path.write_text(json.dumps(bundle_info, indent=2), encoding="utf-8")
    except Exception as e:
        print(f"‚ö†Ô∏è  Warning: Could not write bundle manifest: {e}")
    
    print(f"\nüì¶ Bundle created with {len(bundle_info['scripts'])} scripts")
    print(f"   Directory: {bundle_path}")
    print(f"   Manifest: {manifest_path}")

def do_restore(bundle_dir: str):
    """Restore scripts from a bundle directory."""
    if not which("brew"):
        print("Error: Homebrew ('brew') not found in PATH.", file=sys.stderr)
        sys.exit(127)
    
    bundle_path = Path(bundle_dir).resolve()
    if not bundle_path.exists():
        print(f"Error: Bundle directory '{bundle_path}' does not exist.", file=sys.stderr)
        sys.exit(1)
    
    manifest_path = bundle_path / ".steep-bundle.json"
    if not manifest_path.exists():
        print(f"Error: Bundle manifest not found: {manifest_path}", file=sys.stderr)
        print("This does not appear to be a valid Steep bundle.", file=sys.stderr)
        sys.exit(1)
    
    # Read bundle manifest
    try:
        bundle_info = json.loads(manifest_path.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"Error: Could not read bundle manifest: {e}", file=sys.stderr)
        sys.exit(1)
    
    scripts = bundle_info.get("scripts", [])
    if not scripts:
        print("No scripts found in bundle.")
        return
    
    print(f"üì¶ Restoring {len(scripts)} scripts from bundle:")
    print(f"   Created: {bundle_info.get('created_by', 'Unknown')}")
    if bundle_info.get("created_at"):
        import datetime
        created_date = datetime.datetime.fromtimestamp(bundle_info["created_at"])
        print(f"   Date: {created_date.strftime('%Y-%m-%d %H:%M:%S')}")
    
    success_count = 0
    
    for script_info in scripts:
        filename = script_info["filename"]
        command_name = script_info["command_name"]
        meta = script_info.get("metadata", {})
        
        script_path = bundle_path / filename
        if not script_path.exists():
            print(f"‚ö†Ô∏è  Skipping '{filename}': file not found in bundle")
            continue
        
        print(f"\nüîÑ Installing {filename} ‚Üí {command_name}")
        
        # Check if already installed
        if is_installed(command_name):
            installed_ver, _ = get_formula_info(command_name)
            script_ver = meta.get("version", "unknown")
            print(f"   Already installed: {command_name} ({installed_ver})")
            
            if not prompt_yes_no(f"Upgrade to version {script_ver}", default=True):
                print("   Skipped.")
                continue
        
        # Install using the same logic as main installation
        try:
            # We need to simulate the main installation process
            # This is a simplified version - in practice, you'd refactor main() to be reusable
            print(f"   Installing via: steep install {script_path} --name {command_name} --upgrade")
            
            # For now, suggest manual installation
            print(f"   Run: steep install {script_path} --name {command_name} --upgrade")
            success_count += 1
            
        except Exception as e:
            print(f"   ‚ùå Failed: {e}")
            continue
    
    print(f"\nüì¶ Restore complete: {success_count}/{len(scripts)} scripts processed")
    print("Note: Run the suggested 'steep' commands to complete installation.")

def do_check(script_path: str):
    """Validate script and show what would be installed."""
    script = Path(script_path).expanduser().resolve()
    
    if not script.exists():
        print(f"‚ùå Script not found: {script}", file=sys.stderr)
        sys.exit(2)
    
    print(f"üîç Checking script: {script}\n")
    
    # Check if executable
    if not os.access(script, os.X_OK):
        print("‚ö†Ô∏è  Script is not executable")
        print(f"   Fix with: chmod +x {script}")
    else:
        print("‚úÖ Script is executable")
    
    # Extract metadata
    desc, ver = extract_metadata(script)
    cmd_name = to_cmd_name(script, False)
    
    print(f"\nüìã Metadata:")
    print(f"   Description: {desc or '‚ùå Missing (line 2)'}")
    print(f"   Version: {ver or '‚ùå Missing (line 3)'}")
    print(f"   Command name: {cmd_name}")
    
    # Check file size and hash
    try:
        file_size = script.stat().st_size
        file_hash = sha256_file(script)
        print(f"   Size: {format_size(file_size)}")
        print(f"   SHA256: {file_hash[:16]}...")
    except Exception as e:
        print(f"   ‚ö†Ô∏è  Could not read file stats: {e}")
    
    # Security checks
    print(f"\nüõ°Ô∏è  Security checks:")
    
    # World-writable check
    if is_world_writable_path(script):
        print("‚ö†Ô∏è  Script is in a world-writable directory")
        print(f"   Directory: {script.parent}")
    else:
        print("‚úÖ Directory permissions OK")
    
    # Symlink check
    if script.is_symlink():
        real_path = script.resolve()
        print(f"‚ö†Ô∏è  Script is a symlink")
        print(f"   Target: {real_path}")
    else:
        print("‚úÖ Not a symlink")
    
    # Command conflict check
    has_conflict, conflict_path = check_command_conflict(cmd_name)
    if has_conflict:
        print(f"‚ö†Ô∏è  Command name '{cmd_name}' conflicts with existing binary")
        print(f"   Existing: {conflict_path}")
        
        # Suggest alternatives
        alt_name = suggest_alternative_name(cmd_name)
        if alt_name != cmd_name:
            print(f"   Suggestion: use --name {alt_name}")
    else:
        print(f"‚úÖ Command name '{cmd_name}' is available")
    
    # Brew checks
    if not which("brew"):
        print(f"\n‚ùå Homebrew not found in PATH")
        return
    
    print(f"\nüç∫ Homebrew checks:")
    
    # Check if already installed
    if is_installed(cmd_name):
        installed_ver, _ = get_formula_info(cmd_name)
        print(f"‚ö†Ô∏è  Already installed: {cmd_name} ({installed_ver})")
        
        if ver and installed_ver:
            current = parse_version(installed_ver)
            new = parse_version(ver)
            if new > current:
                print("   ‚Üí This would be an upgrade")
            elif new < current:
                print("   ‚Üí This would be a downgrade (requires --allow-downgrade)")
            else:
                print("   ‚Üí Same version (requires --upgrade)")
    else:
        print(f"‚úÖ Command name available for installation")
    
    # Brew writability
    writable, fix_cmd = check_brew_writable()
    if writable:
        print("‚úÖ Homebrew prefix is writable")
    else:
        print("‚ö†Ô∏è  Homebrew prefix not writable")
        print(f"   Fix with: {fix_cmd}")
    
    # Summary
    print(f"\nüìù Installation command:")
    install_cmd = f"steep install {script}"
    if not desc:
        install_cmd += f" --desc 'DESCRIPTION'"
    if not ver:
        install_cmd += f" --version 'VERSION'"
    print(f"   {install_cmd}")

def do_self_test():
    """Run comprehensive self-test (install, verify, extract, uninstall)."""
    print("üß™ Running Steep self-test...\n")
    
    if not which("brew"):
        print("‚ùå Homebrew not found - cannot run self-test", file=sys.stderr)
        sys.exit(127)
    
    # Create a temporary test script
    test_script_content = '''#!/usr/bin/env bash
# Steep self-test script
# 99.99.99
echo "Steep self-test script executed successfully"
'''
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='-steep-test.sh', delete=False) as f:
        f.write(test_script_content)
        f.flush()
        test_script = Path(f.name)
    
    # Make it executable
    test_script.chmod(0o755)
    
    test_name = "steep-self-test"
    
    try:
        print("1Ô∏è‚É£  Testing installation...")
        
        # Install the test script
        result = subprocess.run([
            sys.executable, __file__, "--quiet", "install", str(test_script),
            "--name", test_name
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"‚ùå Installation failed: {result.stderr}")
            return False
        
        print("   ‚úÖ Installation successful")
        
        print("2Ô∏è‚É£  Testing verification...")
        
        # Verify it's installed and works
        if not is_installed(test_name):
            print("‚ùå Script not found after installation")
            return False
        
        # Test execution
        exec_result = subprocess.run([test_name], capture_output=True, text=True)
        if exec_result.returncode != 0 or "successfully" not in exec_result.stdout:
            print(f"‚ùå Script execution failed: {exec_result.stderr}")
            return False
        
        print("   ‚úÖ Script execution successful")
        
        print("3Ô∏è‚É£  Testing extraction...")
        
        # Test extraction
        with tempfile.TemporaryDirectory() as temp_dir:
            orig_cwd = os.getcwd()
            try:
                os.chdir(temp_dir)
                
                extract_result = subprocess.run([
                    sys.executable, __file__, "--quiet", "extract", test_name
                ], capture_output=True, text=True)
                
                if extract_result.returncode != 0:
                    print(f"‚ùå Extraction failed: {extract_result.stderr}")
                    return False
                
                # Verify extracted file
                extracted = Path(temp_dir) / test_name
                if not extracted.exists():
                    print("‚ùå Extracted file not found")
                    return False
                
                # Verify content
                content = extracted.read_text()
                if "self-test script" not in content:
                    print("‚ùå Extracted content incorrect")
                    return False
                
                print("   ‚úÖ Extraction successful")
                
            finally:
                os.chdir(orig_cwd)
        
        print("4Ô∏è‚É£  Testing list...")
        
        # Test list command
        list_result = subprocess.run([
            sys.executable, __file__, "--quiet", "list"
        ], capture_output=True, text=True)
        
        if list_result.returncode != 0 or test_name not in list_result.stdout:
            print(f"‚ùå List command failed: {list_result.stderr}")
            return False
        
        print("   ‚úÖ List command successful")
        
        print("5Ô∏è‚É£  Testing doctor...")
        
        # Test doctor command
        doctor_result = subprocess.run([
            sys.executable, __file__, "--quiet", "doctor", test_name
        ], capture_output=True, text=True)
        
        if doctor_result.returncode != 0:
            print(f"‚ùå Doctor command failed: {doctor_result.stderr}")
            return False
        
        print("   ‚úÖ Doctor command successful")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Self-test failed with exception: {e}")
        return False
        
    finally:
        print("6Ô∏è‚É£  Cleaning up...")
        
        # Always clean up test script
        try:
            test_script.unlink()
        except Exception:
            pass
        
        # Uninstall test script
        try:
            uninstall_result = subprocess.run([
                sys.executable, __file__, "--quiet", "uninstall", test_name
            ], capture_output=True, text=True)
            
            if uninstall_result.returncode == 0:
                print("   ‚úÖ Cleanup successful")
            else:
                print(f"   ‚ö†Ô∏è  Cleanup warning: {uninstall_result.stderr}")
                
        except Exception as e:
            print(f"   ‚ö†Ô∏è  Cleanup failed: {e}")
        
        print("\nüéâ Self-test completed!")

if __name__ == "__main__":
    main()